<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Re：从零开始的单片机生活（二）- STM32单片机程序的外设与模拟 | dataisland&#39;s home</title>
<link rel="shortcut icon" href="https://cla7aye15i4nd.github.io/favicon.ico?v=1635583231274">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cla7aye15i4nd.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Re：从零开始的单片机生活（二）- STM32单片机程序的外设与模拟 | dataisland&#39;s home - Atom Feed" href="https://cla7aye15i4nd.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="上一篇文章我们讲述了单片机的固件烧录以及reset的过程，总结一下就是做了两件事：

用生成的程序覆盖单片机的内存。
单片机自动初始化pc,sp,lr寄存器，然后程序开始执行。

现在我们开始关注外设，首先我们要回答一个问题，什么是外设？
..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://cla7aye15i4nd.github.io">
  <img class="avatar" src="https://cla7aye15i4nd.github.io/images/avatar.png?v=1635583231274" alt="">
  </a>
  <h1 class="site-title">
    dataisland&#39;s home
  </h1>
  <p class="site-description">
    正因为生来一无所有，所以才能拥有一切，这是身为弱者的骄傲
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Re：从零开始的单片机生活（二）- STM32单片机程序的外设与模拟
            </h2>
            <div class="post-info">
              <span>
                2021-10-29
              </span>
              <span>
                8 min read
              </span>
              
            </div>
            
              <img class="post-feature-image" src="https://cla7aye15i4nd.github.io/post-images/re0-stm32-life-2.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>上一篇文章我们讲述了单片机的固件烧录以及reset的过程，总结一下就是做了两件事：</p>
<ul>
<li>用生成的程序覆盖单片机的内存。</li>
<li>单片机自动初始化<code>pc</code>,<code>sp</code>,<code>lr</code>寄存器，然后程序开始执行。</li>
</ul>
<p>现在我们开始关注外设，首先我们要回答一个问题，什么是外设？</p>
<h2 id="什么是外设">什么是外设？</h2>
<figure data-type="image" tabindex="1"><img src="https://cla7aye15i4nd.github.io/post-images/1635578496869.png" alt="" loading="lazy"></figure>
<p>这里我先放上这样一个图（灵魂画师就是我），之后可能会反复用到这张图。我们先回忆一下上次我们写的那个简单的LED程序，我们是通过什么让指令和LED连接起来，让我们通过代码就能控制LED呢，答案是MMIO和GPIO。</p>
<p>我们需要先有一个认识，就是单片机并不是直接控制LED灯的闪烁，单片机能控制的是一个叫GPIO的东西，然后GPIO再控制LED灯，这样一个间接的过程，就和上图最后一行那样。我们可以把GPIO和LED灯都叫做外设，但是通常来说我们更关注GPIO，因为GPIO由单片机直接控制，处于较为核心的位置。因此我们先来看看GPIO是怎样被单片机所控制的。</p>
<h3 id="mmiomemory-mapped-io">MMIO（Memory-mapped I/O）</h3>
<p>通常来说，控制外设我们就得用外设给我们提供的API，外设的API就是它的寄存器。但单片机所能做的就是执行指令，通过指令来修改或读取内存或是读取它自己的寄存器。但是如果单片机想控制GPIO，就等修改GPIO内部的寄存器，但是单片机不能直接访问到他们，因此MMIO就被提了出来。MMIO通过将GPIO的寄存器映射到单片机的内存上，实现了单片机对外设的直接控制。举个例子，再STM32F411上，GPIO有下面这些寄存器。</p>
<pre><code class="language-c">typedef struct
{
  __IO uint32_t MODER;    /*!&lt; GPIO port mode register,               Address offset: 0x00      */
  __IO uint32_t OTYPER;   /*!&lt; GPIO port output type register,        Address offset: 0x04      */
  __IO uint32_t OSPEEDR;  /*!&lt; GPIO port output speed register,       Address offset: 0x08      */
  __IO uint32_t PUPDR;    /*!&lt; GPIO port pull-up/pull-down register,  Address offset: 0x0C      */
  __IO uint32_t IDR;      /*!&lt; GPIO port input data register,         Address offset: 0x10      */
  __IO uint32_t ODR;      /*!&lt; GPIO port output data register,        Address offset: 0x14      */
  __IO uint32_t BSRR;     /*!&lt; GPIO port bit set/reset register,      Address offset: 0x18      */
  __IO uint32_t LCKR;     /*!&lt; GPIO port configuration lock register, Address offset: 0x1C      */
  __IO uint32_t AFR[2];   /*!&lt; GPIO alternate function registers,     Address offset: 0x20-0x24 */
} GPIO_TypeDef;
</code></pre>
<p>这段代码可以在上次代码中的Drivers\CMSIS\Device\ST\STM32F4xx\Include\stm32f411xe.h中找到，也是STM32CubeMX的代码一部分。如果MMIO将这样一个寄存器集合映射到0x40020000这个内存地址，那么我们通过<code>*((uint32_t*) 0x40020000)</code>就能访问MODER这个寄存器，当然也能修改。除了GPIO之外，单片机还有很多外设，例如USART, I2C, SPI等等。这些外设都由单片机通过MMIO直接控制，我们把这些外设成为on-chip的外设，而不使用MMIO，单片机无法直接控制的外设，我们称为off-chip的外设。on-chip的外设通常为单片提供一些核心功能，我们之后会介绍这些功能。</p>
<h3 id="gpio">GPIO</h3>
<p>说完了MMIO，我们再来看看GPIO是怎么控制LED灯的，还记得我们我们再上一节中我们将PA5设置为了GPIO_OUTPUT吗，这里的PA5代表一个针脚，也就是我们看到的单片两边的刺，我们可以用杜邦线将这些针脚与LCD屏幕，GPS等设备连接，实现更加炫酷的功能，而这里的LED等，是在单片机内部已经和PA5相连了，因此我们不需要杜邦线了。关于针脚的数据，我们可以在<a href="https://os.mbed.com/platforms/ST-Nucleo-F411RE/">这里</a>看到，由图中可以看到，PA5确实和LED相连。<br>
<img src="https://cla7aye15i4nd.github.io/post-images/1635580985201.png" alt="" loading="lazy"></p>
<p>这里我们最后来看一下单片机究竟操作了GPIO的哪些寄存器，具体的控制方式是怎样的，要回答这个问题，我们可以通过阅读代码或者阅读文档的方式解决，但是实际上我们还有第三种方式，那就是使用<a href="https://github.com/qilingframework/qiling">qiling</a>框架，qiling框架已经支持对STM32单片机进行仿真模拟，并且可以打印出外设的访问情况，我们来看看。</p>
<h2 id="单片机程序的模拟">单片机程序的模拟</h2>
<p>这里建议大家不要通过pip安装qiling，直接clone麒麟的仓库，然后切换到dev分支，最新的代码都在dev分支中，然后我们可以直接使用examples下的<a href="https://github.com/qilingframework/qiling/blob/dev/examples/mcu/stm32f411_gpio_hook.py">例子</a>。<br>
这个例子就是模拟了一个自带的LED灯程序，我们修改代码成如下：</p>
<pre><code class="language-python">import sys
sys.path.append(&quot;../..&quot;)

from qiling.core import Qiling
from qiling.const import QL_VERBOSE


def test_mcu_gpio_stm32f411():
    ql = Qiling([&quot;../../examples/rootfs/mcu/stm32f411/hello_gpioA.hex&quot;],                    
                archtype=&quot;cortex_m&quot;, profile=&quot;stm32f411&quot;, verbose=QL_VERBOSE.DEBUG)

    ql.hw.create('rcc')
    ql.hw.create('gpioa').watch()
    

    ql.hw.gpioa.hook_set(5, lambda: print('LED light up'))
    ql.hw.gpioa.hook_reset(5, lambda: print('LED light off'))

    ql.run(count=10000)

if __name__ == &quot;__main__&quot;:
    test_mcu_gpio_stm32f411()
</code></pre>
<p>我们先运行一下，看看输出了什么,</p>
<pre><code class="language-log">[+]     [GPIOA] [R] ODR  = 0x0
[+]     [GPIOA] [W] BSRR = 0x20
[+]     [gpioa] Set PA5
LED light up
[+]     [GPIOA] [R] ODR  = 0x20
[+]     [GPIOA] [W] BSRR = 0x200000
[+]     [gpioa] Reset PA5
LED light off
[+]     [GPIOA] [R] ODR  = 0x0
[+]     [GPIOA] [W] BSRR = 0x20
[+]     [gpioa] Set PA5
LED light up
[+]     [GPIOA] [R] ODR  = 0x20
[+]     [GPIOA] [W] BSRR = 0x200000
[+]     [gpioa] Reset PA5
LED light off
[+]     [GPIOA] [R] ODR  = 0x0
[+]     [GPIOA] [W] BSRR = 0x20
[+]     [gpioa] Set PA5
LED light up
[+]     [GPIOA] [R] ODR  = 0x20
[+]     [GPIOA] [W] BSRR = 0x200000
[+]     [gpioa] Reset PA5
LED light off
[+]     [GPIOA] [R] ODR  = 0x0
</code></pre>
<p>可以看到，单片在反复读取GPIOA的ODR寄存器以及写BSRR的寄存器，然后对应的PA5针脚的状态就会发生变化SET/RESET，然后LED灯的状态也随之改变，具体表现为不停的亮起和熄灭。这与我们实际对LED的观察一致。然后我们再来看看，这个BSRR在GPIO中是作什么用的呢，为什么每次写这个寄存器led灯的状态就会发生变化。我们回答这个问题还是用看文档的方式：<br>
<img src="https://cla7aye15i4nd.github.io/post-images/1635582175869.png" alt="" loading="lazy"><br>
可以看到， 这个寄存器前16位bit代表set，后16位代表reset，通过写对应的bit就可以控制对应的针脚（PIN）。比如要set针脚PA5，就应该写<code>1&lt;&lt;5=0b100000=0x20</code>，这与我们的观察一致。</p>
<h3 id="qiling框架的简单使用">qiling框架的简单使用</h3>
<p>我们简单讲解一下上面qiling框架的代码是怎么回事</p>
<pre><code class="language-python">ql = Qiling([&quot;../../examples/rootfs/mcu/stm32f411/hello_gpioA.hex&quot;],                    
                archtype=&quot;cortex_m&quot;, profile=&quot;stm32f411&quot;, verbose=QL_VERBOSE.DEBUG)
</code></pre>
<p>这里第一行，指定需要模拟的固件的目录，然后是arch类型，以及板子的类型。</p>
<pre><code class="language-python">ql.hw.create('rcc')
ql.hw.create('gpioa').watch()
</code></pre>
<p>这里两行创建必要的外设，为什么需要rcc我们以后会说，这里可以认为rcc是一个stm32f4系列一个必不可少的外设，而后面加上<code>.watch()</code>代表我们需要监视这个外设的访问情况。</p>
<pre><code class="language-python">ql.hw.gpioa.hook_set(5, lambda: print('LED light up'))
ql.hw.gpioa.hook_reset(5, lambda: print('LED light off'))
</code></pre>
<p>这里表示，在PA5针脚状态被设置后，我希望进行的一些操作，这里只是简单的做一些输出。</p>
<pre><code class="language-python">ql.run(count=10000)
</code></pre>
<p>运行10000条指令。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%96%E8%AE%BE">什么是外设？</a>
<ul>
<li><a href="#mmiomemory-mapped-io">MMIO（Memory-mapped I/O）</a></li>
<li><a href="#gpio">GPIO</a></li>
</ul>
</li>
<li><a href="#%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A8%A1%E6%8B%9F">单片机程序的模拟</a>
<ul>
<li><a href="#qiling%E6%A1%86%E6%9E%B6%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">qiling框架的简单使用</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://cla7aye15i4nd.github.io/post/re0-stm32-life-1/">
              <h3 class="post-title">
                Re：从零开始的单片机生活（一）- STM32单片机程序的开发与加载
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Maintained by~ <a href='https://github.com/cla7aye15I4nd'> dataisland</a>
  <a class="rss" href="https://cla7aye15i4nd.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
