<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Re：从零开始的单片机生活（一）- STM32单片机程序的开发与加载 | dataisland&#39;s home</title>
<link rel="shortcut icon" href="https://www.fibxx.com/favicon.ico?v=1635684521716">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://www.fibxx.com/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Re：从零开始的单片机生活（一）- STM32单片机程序的开发与加载 | dataisland&#39;s home - Atom Feed" href="https://www.fibxx.com/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
本文章讲述了如何在STM32F11上开发一个简单的让LED灯闪烁的程序并讲解了单片机运行固件的具体流程。理论上来说，学习单片机的难度是严格小于学习操作系统和计算机体系结构这两门课程的难度。因为这两门课程探究的是现代计算机这样一个拥有优秀的..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://www.fibxx.com">
  <img class="avatar" src="https://www.fibxx.com/images/avatar.png?v=1635684521716" alt="">
  </a>
  <h1 class="site-title">
    dataisland&#39;s home
  </h1>
  <p class="site-description">
    正因为生来一无所有，所以才能拥有一切，这是身为弱者的骄傲
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://www.fibxx.com/post/link" class="menu">
          友链
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Re：从零开始的单片机生活（一）- STM32单片机程序的开发与加载
            </h2>
            <div class="post-info">
              <span>
                2021-10-28
              </span>
              <span>
                6 min read
              </span>
              
            </div>
            
              <img class="post-feature-image" src="https://www.fibxx.com/post-images/re0-stm32-life-1.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <!-- more -->
<p>本文章讲述了如何在STM32F11上开发一个简单的让LED灯闪烁的程序并讲解了单片机运行固件的具体流程。理论上来说，学习单片机的难度是严格小于学习操作系统和计算机体系结构这两门课程的难度。因为这两门课程探究的是现代计算机这样一个拥有优秀的性能以及丰富的功能的原理，包含了计算机发展历程中无数人的工作与智慧，我们需要的了解的包括但不限于：中断处理，线程调度，虚拟内存管理，文件系统，指令集，驱动。然而，在单片机中的内容则只是上述内容的一个子集，我们可以先只关注指令，内存以及中断，只要明白这三样事情，就足以理解单片机程序的开发和加载原理。在此之前，我们先来写第一个单片机程序。</p>
<h2 id="开发环境准备">开发环境准备</h2>
<ol>
<li>安装arm的交叉编译器，因为stm32f4系列的核心使用的都是cortex-m4的指令集，cortex-m4可以认为是arm的一个变种。编译器可以在<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">ARM官方网站</a>下载到，可以选择直接下载已经编译好的二进制文件或者下载源码进行本地编译。</li>
<li>安装<a href="https://www.st.com/en/development-tools/stm32cubemx.html">STM32CubeMX</a>，这个工具的目的是为了帮我们自动生成一些初始化代码，如果没有这样的工具，开发单片机将会变成一件很麻烦的事情，后面会说明原因。</li>
<li>安装st-link，具体过程可以参见<a href="https://freeelectron.ro/installing-st-link-v2-to-flash-stm32-targets-on-linux/">这里</a>，这个工具的目的是将我们写好的程序烧录到板子上。</li>
</ol>
<h2 id="第一个led灯程序">第一个LED灯程序</h2>
<ol>
<li>我们打开STM32CubeMX，点击 File -&gt; New Project，选择我们自己板子的型号，这里我的板子是STM32F411RE。<br>
<img src="https://www.fibxx.com/post-images/1635430749676.png" alt="" loading="lazy"></li>
<li>然后点击Start Project，可以看到一块正方形的板子被一些带有字母数字的标签围着，选择带有PA5的标签，如果找不到可以用右下角的搜索框搜索，之后点击GPIO_Output。<br>
<img src="https://www.fibxx.com/post-images/1635431000254.png" alt="" loading="lazy"></li>
<li>最后点击Project Manager，选择项目保存的位置，ToolChain/IDE那一栏我们选择Makefile，因为我不打算使用定制的IDE，而是直接使用vscode这样的编辑器。</li>
<li>找到项目保存位置的Core/Src/main.c，在main函数最后可以看到一个<code>while</code>循环，在里面添加如下代码：</li>
</ol>
<pre><code class="language-c">while (1)
{
    /* USER CODE END WHILE */
    HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5); //Toggle the state of pin PA5
    HAL_Delay(1000); //delay 1000ms
}
</code></pre>
<ol start="5">
<li>然后直接编译以及烧录:</li>
</ol>
<pre><code class="language-bash">make
st-flash --format=ihex write build/{your_project_name}.hex
</code></pre>
<ol start="6">
<li>最后点击板子上的reset键，我们就可以看到板子的LED灯开始闪烁了。</li>
</ol>
<h2 id="程序是如何运行的">程序是如何运行的</h2>
<h3 id="烧录程序">烧录程序</h3>
<p>要弄清楚这个问题，我们可以先研究一下STM32CubeMx为我们生成的Makefile，可以发现这个makefile首先为我们生成了elf，然后使用<code>objcopy</code>，用下面的命令生成可bin文件和hex文件，这样做的目的是去除elf中无用的头部以及符号表等信息。</p>
<pre><code class="language-bash">arm-none-eabi-objcopy -O ihex target/led.hex
arm-none-eabi-objcopy -O binary target/led.bin
</code></pre>
<p>这里需要插一句关于单片的内存的内容，单片机没有虚拟内存这回事，至少STM32F4是没有的。因此我们如果在程序使用指针，都是直接操作物理地址。因此任何时候提到地址，都是说的绝对的物理地址。<br>
回到这两个文件，hex文件指的是<a href="https://en.wikipedia.org/wiki/Intel_HEX">Intel Hex</a>，文件内容可以认为是一个个的形如(地址，数据)的二元组，告诉st-flash根据这些二元组将数据写入到对应单片机的地址上。而bin文件则只有数据，没有地址所以如果我们想烧录bin文件需要像下面这样指定要烧录的地址：</p>
<pre><code class="language-bash">st-flash write build/led.bin 0x8000000
</code></pre>
<p>这条命令是说让bin原模原样的覆盖0x8000000开始的地址的内容。了解了这两个文件后，我们可以认为烧录这一过程<strong>改变了单片的一部分内存数据</strong>，我们还需要关注寄存器是如何变化的。</p>
<h3 id="单片机重置reset">单片机重置(Reset)</h3>
<p>我们在烧录过后，还点击了单片上的Reset按钮，这一步单片及内部发生了什么呢。我们可以参考官方的Cortex-M4文档，在有关寄存器的章节，这里说了会将pc的值覆盖为地址0x00000004处的值，另外还提到了sp的值会被0x0处的值所覆盖。<br>
<img src="https://www.fibxx.com/post-images/1635434118723.png" alt="" loading="lazy"></p>
<p>但是问题是0x00000004处的值是什么呢，我们可以在STM32F411的文档中找到答案：<br>
<img src="https://www.fibxx.com/post-images/1635434260158.png" alt="" loading="lazy"><br>
简单来说，在通常情况下，单片机访问0x00000000 ~ 0x0007FFFF(这一段内存相当于访问Main Flash memory，而 Main Flash memory 正是在 0x8000000。因此这也意味着PC的值是0x8000004这个地址的值。</p>
<p>这里我们可以用ghidra逆向一下生成的led.elf文件，看看0x8000004处的内容是什么。<br>
<img src="https://www.fibxx.com/post-images/1635434743582.png" alt="" loading="lazy"><br>
可以很清楚的看到pc会被置成Reset_Handler的地址，我们可以在我们的代码中搜索Reset_Handler可以发现这是STM32CubeMX为我们生成的代码，它的作用是执行一些全局变量的初始化工作以及跳转到main函数，具体来说我们平常在linux上会将程序分成很多段，例如全局变量，代码，堆，栈等等，但是这里我们注意到我们是把程序一股脑的放到了0x8000000的位置，因此我们需要做一个初始化的操作将全局变量和栈恢复到正确状态，因此这个函数做了大量的复制操作去干这件事。<br>
如果仔细看这这个函数，还是会发现它的实现不是特别简单，但是每个单片机程序都需要它，相当于一个模板一样的东西，每次都手动编写或者复制过来很麻烦，因此STMCubeMX就是在这样的地方发挥作用，让我们不需要去写那些重复的代码。</p>
<h3 id="led灯是如何闪烁的">LED灯是如何闪烁的</h3>
<p>到这一步程序已经开始执行main函数，但是它到底是通过什么是LED灯闪的呢？这一部分内容我们放到下一篇文章。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87">开发环境准备</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AAled%E7%81%AF%E7%A8%8B%E5%BA%8F">第一个LED灯程序</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84">程序是如何运行的</a>
<ul>
<li><a href="#%E7%83%A7%E5%BD%95%E7%A8%8B%E5%BA%8F">烧录程序</a></li>
<li><a href="#%E5%8D%95%E7%89%87%E6%9C%BA%E9%87%8D%E7%BD%AEreset">单片机重置(Reset)</a></li>
<li><a href="#led%E7%81%AF%E6%98%AF%E5%A6%82%E4%BD%95%E9%97%AA%E7%83%81%E7%9A%84">LED灯是如何闪烁的</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        

        <div class="site-footer">
  Maintained by~ <a href='https://github.com/cla7aye15I4nd'> dataisland</a>
  <a class="rss" href="https://www.fibxx.com/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
